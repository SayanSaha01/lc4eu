# This program compares the MRS generated by LC with the ACE parser output
# Command to install the prerequisit: pip install pydelphin
# To run:  python3 lc-debugger.py ../tmp_dir/2/2_mrs "The teacher has just come."

import sys
import subprocess
from pathlib import Path
from collections import defaultdict
from delphin.codecs.simplemrs import load, loads, decode

HOME = str(Path.home())


class bcolors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


def warn_print(s):
    print(f"{bcolors.WARNING + bcolors.BOLD}{s}{bcolors.ENDC}")


def fail_print(s):
    print(f"{bcolors.FAIL + bcolors.BOLD}{s}{bcolors.ENDC}")


def safe_print(s):
    print(f"{bcolors.OKGREEN + bcolors.BOLD}{s}{bcolors.ENDC}")


def cyan_print(s):
    print(f"{bcolors.OKCYAN + bcolors.BOLD}{s}{bcolors.ENDC}")


def star_line(s=""):
    if len(s) != 0:
        s = " " + s + " "
    ct = 40 - (len(s) // 2)
    s = "*" * ct + s + "*" * ct
    cyan_print(s)


try:
    lcMrsPath = sys.argv[1]
    english_sentence = sys.argv[2]
    try:
        with open(lcMrsPath, "r") as f:
            fr = f.read()
    except:
        fail_print("(lc mrs output path) is Not Valid.")
        exit()
except:
    fail_print(
        'Command is not Valid => eg (python3 mrs-binding.py "lc mrs output path" "English Sentence")'
    )
    exit()

try:
    with open(".ace_input", "w") as f:
        f.write(english_sentence)
except:
    fail_print("Unable to write temporary file .ace_input")


run_ace_command = [
    HOME + "/ace-0.9.34/ace",
    "-g",
    HOME + "/ace-0.9.34/erg-1214-x86-64-0.9.34.dat",
    "-1Tfq",
    ".ace_input",
]
try:
    result = subprocess.run(run_ace_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    ace_output = str(result.stdout, "utf-8")
except:
    fail_print("Failed to run ace.")
if ace_output == "":
    fail_print("Failed to run ace.")


def parse_simplemrs(data):
    try:
        obj = decode(data)
    except:
        fail_print("Invalid MRS Object")
        print(data)
        exit()
    return obj


def make_var_arg_dict(obj):
    args = defaultdict(list)
    args[obj.top].append("LTOP")
    for p in obj.predications:
        for key, value in p.args.items():
            args[value].append((p.predicate, key))
        args[p.label].append((p.predicate, "LBL"))
    for key in args:
        args[key].sort()
    return args


def get_predicates(exp, recv):
    exp_pred = [i.predicate for i in exp.rels]
    recv_pred = [i.predicate for i in recv.rels]
    all_pred = list(set(exp_pred + recv_pred))
    return exp_pred, recv_pred, all_pred


def compare_rels(exp, recv):
    star_line("Predicates Comparison")
    exp_pred, recv_pred, all_pred = get_predicates(exp, recv)
    for p in all_pred:
        if p in exp_pred and p in recv_pred:
            safe_print(p + ": Correct")
        elif p in exp_pred and p not in recv_pred:
            fail_print(p + ": Missing")
        elif p not in exp_pred and p in recv_pred:
            warn_print(p + ": Not expected")
        else:
            print(p + ": Missing from both :(")
    star_line()


def compare_properties(exp, recv):
    star_line("Properties Comparison")
    exp_pred_prop = {exp[id].predicate: exp.properties(id) for id in exp._pidx}
    recv_pred_prop = {recv[id].predicate: recv.properties(id) for id in recv._pidx}
    all_idx = set([i.predicate for i in exp.rels] + [i.predicate for i in recv.rels])
    for idx in all_idx:
        if idx not in exp_pred_prop:
            warn_print(idx + ": Not exp")
            continue
        if idx not in recv_pred_prop:
            fail_print(idx + ": Missing")
            continue
        print("Comparing properties for ", idx)
        exp_prop = exp_pred_prop[idx]
        recv_prop = recv_pred_prop[idx]
        all_properties = set(list(exp_prop.keys()) + list(recv_prop.keys()))
        for property in all_properties:
            if property not in exp_prop:
                warn_print(
                    property + ": Property Not Expected: Value: " + recv_prop[property]
                )
                continue
            if property not in recv_prop:
                fail_print(
                    property + ": Property Missing Expected: " + exp_prop[property]
                )
                continue
            exp_value = exp_prop[property]
            recv_value = recv_prop[property]
            if exp_value != recv_value:
                fail_print(
                    property + ": Received: " + recv_value + "Expected: " + exp_value
                )
                continue
            safe_print(property + ": OK " + exp_value)
    star_line()


def compare_valuetype_for_predicate(pred, exp, recv):
    print("Comparing Valuetypes for " + pred)
    exp_args = [ele.args for ele in exp.predications if ele.predicate == pred][0]
    recv_args = [ele.args for ele in recv.predications if ele.predicate == pred][0]
    common_args = list(set(list(exp_args.keys()) + list(recv_args.keys())))
    for arg in common_args:
        if arg not in exp_args:
            warn_print(arg + ": Unexpected argument")
            continue
        if arg not in recv_args:
            fail_print(arg + ": Missing argument")
            continue
        if exp_args[arg][0] != recv_args[arg][0]:
            fail_print(
                arg
                + ": Wrong ValueType Expected: "
                + exp_args[arg][0]
                + " Received: "
                + recv_args[arg][0]
            )
            continue
        safe_print(arg + " Correct ValueType " + exp_args[arg][0])


def compare_qeq(exp, recv):
    star_line("QEQ Bindings Comparison")
    exp_hcons, recv_hcons = exp.hcons, recv.hcons
    exp_args, recv_args = make_var_arg_dict(exp), make_var_arg_dict(recv)
    exp_bindings = []
    for hc in exp_hcons:
        exp_bindings.append((tuple(exp_args[hc.hi]), tuple(exp_args[hc.lo])))
    recv_bindings = []
    for hc in recv_hcons:
        recv_bindings.append((tuple(recv_args[hc.hi]), tuple(recv_args[hc.lo])))
    recv_set = {i for i in recv_bindings}
    exp_set = {i for i in exp_bindings}
    for it in recv_set.union(exp_set):
        if it in recv_set and it in exp_set:
            safe_print(str(it) + ": Correct")
        elif it not in exp_set:
            warn_print(str(it) + ": Not expected")
        elif it not in recv_set:
            fail_print(str(it) + ": Missing")
    star_line()


def compare_arguments(exp, recv):
    star_line("Argument Sharing Comparison")
    recv_args = make_var_arg_dict(recv)
    exp_args = make_var_arg_dict(exp)
    recv_set = {tuple(i) for i in recv_args.values()}
    exp_set = {tuple(i) for i in exp_args.values()}
    for it in recv_set.union(exp_set):
        if it in recv_set and it in exp_set:
            safe_print(str(it) + ": Correct")
        elif it not in exp_set:
            warn_print(str(it) + ": Not expected")
        elif it not in recv_set:
            fail_print(str(it) + ": Missing")
    star_line()


def compare_valuetypes(exp, recv):
    star_line("ValueType Comparison")
    exp_pred, recv_pred, all_pred = get_predicates(exp, recv)
    for p in all_pred:
        if p in exp_pred and p in recv_pred:
            compare_valuetype_for_predicate(p, exp, recv)
        elif p in exp_pred and p not in recv_pred:
            fail_print(p + ": Predicate Missing")
        elif p not in exp_pred and p in recv_pred:
            warn_print(p + ": Predicate Unexpected")
        else:
            print(p + ": Missing from both :(")


def compare_output(exp_output, recv_output):
    exp_object = parse_simplemrs(exp_output)
    recv_object = parse_simplemrs(recv_output)
    compare_rels(exp_object, recv_object)
    compare_arguments(exp_object, recv_object)
    compare_valuetypes(exp_object, recv_object)
    compare_properties(exp_object, recv_object)
    compare_qeq(exp_object, recv_object)
    return


star_line("ACE MRS Output")
print(ace_output.strip())
star_line("End")
star_line("lc.sh MRS Output")
print(fr)
star_line("End")
if __name__ == "__main__":
    compare_output(ace_output, fr)
